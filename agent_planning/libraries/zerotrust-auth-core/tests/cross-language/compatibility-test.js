/**
 * Cross-language compatibility tests for Zero Trust Authentication Core
 * 
 * This test suite ensures that JWT tokens generated by one language 
 * can be validated by all other language implementations.
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Test configuration
const TEST_SECRET = 'test-secret-key-32-characters-long-for-cross-language-testing';
const TEST_USER_ID = 'cross-lang-test-user';
const TEST_EMAIL = 'test@crosslang.example.com';
const TEST_TRUST_LEVEL = 75;

// Language implementations
const LANGUAGES = ['go', 'typescript', 'python', 'java'];

// Test results storage
const testResults = {
  tokenGeneration: {},
  tokenValidation: {},
  trustCalculation: {},
  compatibility: {}
};

/**
 * Generate tokens using each language implementation
 */
async function generateTokens() {
  console.log('🔄 Generating tokens across all languages...');
  
  for (const lang of LANGUAGES) {
    try {
      const token = await generateTokenWithLanguage(lang);
      testResults.tokenGeneration[lang] = {
        success: true,
        token: token,
        timestamp: new Date().toISOString()
      };
      console.log(`✅ ${lang.toUpperCase()}: Token generated successfully`);
    } catch (error) {
      testResults.tokenGeneration[lang] = {
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()
      };
      console.error(`❌ ${lang.toUpperCase()}: Token generation failed - ${error.message}`);
    }
  }
}

/**
 * Validate tokens across all language combinations
 */
async function validateTokensAcrossLanguages() {
  console.log('🔄 Validating tokens across all language combinations...');
  
  for (const generatorLang of LANGUAGES) {
    if (!testResults.tokenGeneration[generatorLang]?.success) {
      console.log(`⏭️  Skipping validation for ${generatorLang} (token generation failed)`);
      continue;
    }
    
    const token = testResults.tokenGeneration[generatorLang].token;
    testResults.compatibility[generatorLang] = {};
    
    for (const validatorLang of LANGUAGES) {
      try {
        const claims = await validateTokenWithLanguage(validatorLang, token);
        testResults.compatibility[generatorLang][validatorLang] = {
          success: true,
          claims: claims,
          timestamp: new Date().toISOString()
        };
        console.log(`✅ ${generatorLang} → ${validatorLang}: Token validation successful`);
      } catch (error) {
        testResults.compatibility[generatorLang][validatorLang] = {
          success: false,
          error: error.message,
          timestamp: new Date().toISOString()
        };
        console.error(`❌ ${generatorLang} → ${validatorLang}: Token validation failed - ${error.message}`);
      }
    }
  }
}

/**
 * Test trust level calculations across languages
 */
async function testTrustCalculations() {
  console.log('🔄 Testing trust level calculations across languages...');
  
  const testFactors = {
    deviceVerified: true,
    locationVerified: true,
    behaviorNormal: true,
    recentActivity: true,
    hardwareAttestation: false,
    biometricVerified: false,
    networkTrusted: true,
    previousTrustLevel: 50
  };
  
  for (const lang of LANGUAGES) {
    try {
      const trustLevel = await calculateTrustWithLanguage(lang, testFactors);
      testResults.trustCalculation[lang] = {
        success: true,
        trustLevel: trustLevel,
        factors: testFactors,
        timestamp: new Date().toISOString()
      };
      console.log(`✅ ${lang.toUpperCase()}: Trust calculation successful (level: ${trustLevel})`);
    } catch (error) {
      testResults.trustCalculation[lang] = {
        success: false,
        error: error.message,
        timestamp: new Date().toISOString()
      };
      console.error(`❌ ${lang.toUpperCase()}: Trust calculation failed - ${error.message}`);
    }
  }
}

/**
 * Generate token using specific language implementation
 */
async function generateTokenWithLanguage(language) {
  const testData = {
    secret: TEST_SECRET,
    userId: TEST_USER_ID,
    email: TEST_EMAIL,
    trustLevel: TEST_TRUST_LEVEL,
    roles: ['user', 'test'],
    permissions: ['read', 'write']
  };
  
  switch (language) {
    case 'go':
      return generateGoToken(testData);
    case 'typescript':
      return generateTypeScriptToken(testData);
    case 'python':
      return generatePythonToken(testData);
    case 'java':
      return generateJavaToken(testData);
    default:
      throw new Error(`Unsupported language: ${language}`);
  }
}

/**
 * Validate token using specific language implementation
 */
async function validateTokenWithLanguage(language, token) {
  const testData = {
    secret: TEST_SECRET,
    token: token
  };
  
  switch (language) {
    case 'go':
      return validateGoToken(testData);
    case 'typescript':
      return validateTypeScriptToken(testData);
    case 'python':
      return validatePythonToken(testData);
    case 'java':
      return validateJavaToken(testData);
    default:
      throw new Error(`Unsupported language: ${language}`);
  }
}

/**
 * Calculate trust using specific language implementation
 */
async function calculateTrustWithLanguage(language, factors) {
  switch (language) {
    case 'go':
      return calculateGoTrust(factors);
    case 'typescript':
      return calculateTypeScriptTrust(factors);
    case 'python':
      return calculatePythonTrust(factors);
    case 'java':
      return calculateJavaTrust(factors);
    default:
      throw new Error(`Unsupported language: ${language}`);
  }
}

// Language-specific implementations
async function generateGoToken(testData) {
  const script = `
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    "github.com/zerotrust/auth-core-go/v1/pkg/jwt"
)

func main() {
    config := &jwt.Config{
        Secret:          "${testData.secret}",
        ExpiryDuration:  30 * time.Minute,
        RefreshDuration: 7 * 24 * time.Hour,
        Issuer:          "cross-lang-test",
    }
    
    manager, err := jwt.NewManager(config)
    if err != nil {
        panic(err)
    }
    
    request := &jwt.TokenRequest{
        UserID:      "${testData.userId}",
        Email:       "${testData.email}",
        Roles:       []string{"user", "test"},
        Permissions: []string{"read", "write"},
        TrustLevel:  ${testData.trustLevel},
    }
    
    token, err := manager.GenerateToken(context.Background(), request)
    if err != nil {
        panic(err)
    }
    
    fmt.Print(token.AccessToken)
}`;
  
  fs.writeFileSync('/tmp/go_token_test.go', script);
  return execSync('cd /tmp && go run go_token_test.go', { encoding: 'utf8' }).trim();
}

async function generateTypeScriptToken(testData) {
  const { JWTManager, createDefaultJWTConfig } = require('../../packages/typescript/dist/index.js');
  
  const config = createDefaultJWTConfig({
    secret: testData.secret,
    issuer: 'cross-lang-test'
  });
  
  const manager = new JWTManager(config);
  
  const request = {
    userId: testData.userId,
    email: testData.email,
    roles: testData.roles,
    permissions: testData.permissions,
    trustLevel: testData.trustLevel
  };
  
  const token = await manager.generateToken(request);
  return token.accessToken;
}

async function generatePythonToken(testData) {
  const script = `
import asyncio
import sys
sys.path.append('../../packages/python/src')

from zerotrust_auth_core import JWTManager, create_default_jwt_config, TokenRequest

async def main():
    config = create_default_jwt_config(
        secret="${testData.secret}",
        issuer="cross-lang-test"
    )
    
    manager = JWTManager(config)
    
    request = TokenRequest(
        user_id="${testData.userId}",
        email="${testData.email}",
        roles=["user", "test"],
        permissions=["read", "write"],
        trust_level=${testData.trustLevel}
    )
    
    token = await manager.generate_token(request)
    print(token.access_token)

asyncio.run(main())`;
  
  fs.writeFileSync('/tmp/python_token_test.py', script);
  return execSync('cd /tmp && python python_token_test.py', { encoding: 'utf8' }).trim();
}

async function generateJavaToken(testData) {
  const script = `
import com.zerotrust.authcore.jwt.*;
import com.zerotrust.authcore.trust.TrustLevel;
import java.time.Duration;
import java.util.List;

public class TokenTest {
    public static void main(String[] args) {
        JWTConfig config = JWTConfig.builder()
            .secret("${testData.secret}")
            .expiryDuration(Duration.ofMinutes(30))
            .refreshDuration(Duration.ofDays(7))
            .issuer("cross-lang-test")
            .build();
        
        JWTManager manager = new JWTManager(config);
        
        TokenRequest request = TokenRequest.builder()
            .userId("${testData.userId}")
            .email("${testData.email}")
            .roles(List.of("user", "test"))
            .permissions(List.of("read", "write"))
            .trustLevel(${testData.trustLevel})
            .build();
        
        Token token = manager.generateToken(request).join();
        System.out.print(token.getAccessToken());
    }
}`;
  
  fs.writeFileSync('/tmp/TokenTest.java', script);
  execSync('cd /tmp && javac -cp "../../packages/java/target/*" TokenTest.java');
  return execSync('cd /tmp && java -cp ".:../../packages/java/target/*" TokenTest', { encoding: 'utf8' }).trim();
}

// Similar implementations for validation and trust calculation...
// (Implementation details truncated for brevity)

/**
 * Analyze compatibility results
 */
function analyzeResults() {
  console.log('\n📊 Compatibility Analysis:');
  
  // Check token generation success rate
  const genSuccess = LANGUAGES.filter(lang => testResults.tokenGeneration[lang]?.success).length;
  console.log(`Token Generation: ${genSuccess}/${LANGUAGES.length} languages successful`);
  
  // Check cross-language validation
  let totalValidations = 0;
  let successfulValidations = 0;
  
  for (const gen of LANGUAGES) {
    if (testResults.compatibility[gen]) {
      for (const val of LANGUAGES) {
        totalValidations++;
        if (testResults.compatibility[gen][val]?.success) {
          successfulValidations++;
        }
      }
    }
  }
  
  console.log(`Cross-Language Validation: ${successfulValidations}/${totalValidations} combinations successful`);
  
  // Check trust calculation consistency
  const trustLevels = LANGUAGES
    .filter(lang => testResults.trustCalculation[lang]?.success)
    .map(lang => testResults.trustCalculation[lang].trustLevel);
  
  const uniqueTrustLevels = [...new Set(trustLevels)];
  const isConsistent = uniqueTrustLevels.length <= 1;
  
  console.log(`Trust Calculation Consistency: ${isConsistent ? 'PASS' : 'FAIL'}`);
  if (!isConsistent) {
    console.log(`  Different results: ${uniqueTrustLevels.join(', ')}`);
  }
  
  return {
    tokenGeneration: genSuccess === LANGUAGES.length,
    crossValidation: successfulValidations === totalValidations,
    trustConsistency: isConsistent,
    overall: genSuccess === LANGUAGES.length && 
             successfulValidations === totalValidations && 
             isConsistent
  };
}

/**
 * Generate detailed test report
 */
function generateReport() {
  const analysis = analyzeResults();
  
  const report = {
    testSuite: 'Zero Trust Authentication Core - Cross-Language Compatibility',
    timestamp: new Date().toISOString(),
    summary: {
      status: analysis.overall ? 'PASS' : 'FAIL',
      tokenGeneration: analysis.tokenGeneration,
      crossValidation: analysis.crossValidation,
      trustConsistency: analysis.trustConsistency
    },
    results: testResults,
    recommendations: generateRecommendations(analysis)
  };
  
  // Save detailed report
  fs.writeFileSync('./test-reports/cross-language-compatibility.json', JSON.stringify(report, null, 2));
  
  console.log('\n📋 Test Report Generated: ./test-reports/cross-language-compatibility.json');
  
  return report;
}

/**
 * Generate recommendations based on test results
 */
function generateRecommendations(analysis) {
  const recommendations = [];
  
  if (!analysis.tokenGeneration) {
    recommendations.push('Fix token generation failures before proceeding with release');
  }
  
  if (!analysis.crossValidation) {
    recommendations.push('Investigate JWT compatibility issues between language implementations');
  }
  
  if (!analysis.trustConsistency) {
    recommendations.push('Align trust calculation algorithms across all language implementations');
  }
  
  if (analysis.overall) {
    recommendations.push('All compatibility tests passed - ready for release');
  }
  
  return recommendations;
}

/**
 * Main test execution
 */
async function runCompatibilityTests() {
  console.log('🚀 Starting Cross-Language Compatibility Tests\n');
  
  try {
    // Ensure test reports directory exists
    if (!fs.existsSync('./test-reports')) {
      fs.mkdirSync('./test-reports', { recursive: true });
    }
    
    // Run test phases
    await generateTokens();
    console.log();
    
    await validateTokensAcrossLanguages();
    console.log();
    
    await testTrustCalculations();
    console.log();
    
    // Generate and analyze results
    const report = generateReport();
    
    console.log(`\n🎯 Overall Result: ${report.summary.status}`);
    
    if (report.summary.status === 'FAIL') {
      console.log('\n📝 Recommendations:');
      report.recommendations.forEach(rec => console.log(`  • ${rec}`));
      process.exit(1);
    } else {
      console.log('\n🎉 All cross-language compatibility tests passed!');
    }
    
  } catch (error) {
    console.error('\n💥 Test execution failed:', error);
    process.exit(1);
  }
}

// Run tests if executed directly
if (require.main === module) {
  runCompatibilityTests();
}

module.exports = {
  runCompatibilityTests,
  generateReport,
  analyzeResults
};