# Server Architecture & Build Integration

## Application Structure

### Entry Point (`cmd/server/main.go`)
```go
// The main server handles:
// 1. Configuration loading
// 2. Service initialization  
// 3. HTTP server setup
// 4. Graceful shutdown

func main() {
    // Load configuration
    cfg, err := config.Load()
    
    // Initialize server with all services
    server, err := NewServer(cfg)
    
    // Start with graceful shutdown
    server.Start(ctx)
}
```

### Server Components Built
When you run `make build-server`, it compiles a single binary that includes:

#### Core Services
- **HTTP Server** (Fiber framework)
- **Database** (PostgreSQL with GORM)  
- **Redis Cache** (Optional)
- **JWT Authentication**
- **Authorization** (Casbin RBAC)
- **Observability** (OpenTelemetry, Prometheus, Jaeger)

#### HTTP Handlers
- **Auth Handler** - Login, register, refresh tokens
- **Device Handler** - Device attestation, verification
- **Admin Handler** - User/role management  
- **System Handler** - Health checks, metrics

#### Middleware Stack
- **Recovery** - Panic recovery
- **CORS** - Cross-origin requests
- **Tracing** - Distributed tracing
- **Observability** - Metrics and logging
- **Authentication** - JWT validation
- **Authorization** - Permission checking

## Build-time Features

### Version Injection
```go
// These variables are set at build time via LDFLAGS
var (
    version   = "dev"      // From git tags
    commit    = "unknown"  // Git commit SHA
    buildTime = "unknown"  // ISO timestamp
)

// Available at runtime
curl http://localhost:8080/version
{
  "version": "v1.0.0-dirty",
  "commit": "4363a0e1234567890abcdef", 
  "buildTime": "2024-01-15T10:30:45Z"
}
```

### Configuration System
The build includes a flexible configuration system:

```go
type Config struct {
    HTTP struct {
        Host         string        `yaml:"host"`
        Port         int           `yaml:"port"`
        ReadTimeout  time.Duration `yaml:"read_timeout"`
        WriteTimeout time.Duration `yaml:"write_timeout"`
    } `yaml:"http"`
    
    Database struct {
        Host     string `yaml:"host"`
        Port     int    `yaml:"port"`
        Name     string `yaml:"name"`
        User     string `yaml:"user"`
        Password string `yaml:"password"`
    } `yaml:"database"`
    
    Security struct {
        JWT struct {
            Secret     string        `yaml:"secret"`
            Expiration time.Duration `yaml:"expiration"`
        } `yaml:"jwt"`
    } `yaml:"security"`
}
```

### Swagger Documentation 
The build automatically includes Swagger docs:

```go
// Auto-generated by swag init
import _ "mvp.local/docs"

// Available at runtime
// http://localhost:8080/swagger/index.html
s.app.Get("/swagger/*", swagger.HandlerDefault)
```

## Runtime Characteristics

### Service Discovery
The built server automatically discovers and initializes services:

```go
func NewServer(cfg *Config) (*Server, error) {
    // 1. Initialize observability (metrics, tracing, logging)
    obs, err := observability.New(obsConfig)
    
    // 2. Connect to database
    db := database.NewDatabase(&cfg.Database)
    db.Connect()
    db.Migrate()  // Auto-migration
    
    // 3. Initialize Redis (optional)
    if cfg.Redis.Host != "" {
        redisClient = redis.NewClient(&redis.Options{...})
    }
    
    // 4. Setup JWT and Authorization
    jwtService := auth.NewJWTService(&cfg.Security.JWT, authzService)
    
    // 5. Create HTTP server with middleware
    app := fiber.New(fiber.Config{...})
    server.setupMiddleware()
    server.setupRoutes()
    
    return server, nil
}
```

### Health Check Integration
Built-in health checks for operational monitoring:

```go
// Basic health check (public)
GET /health
{
  "status": "healthy",
  "timestamp": "2024-01-15T10:30:45Z",
  "services": {
    "database": {"status": "healthy", "response_time": "2ms"},
    "redis": {"status": "healthy", "response_time": "1ms"}
  }
}

// Detailed system health (authenticated)
GET /system/health
{
  "status": "healthy",
  "services": {
    "database": {
      "status": "healthy",
      "details": {"connections": 5, "max_connections": 100}
    },
    "redis": {
      "status": "healthy", 
      "details": {"memory": "1.2MB", "clients": 3}
    }
  }
}
```

### Graceful Shutdown
The built server handles graceful shutdown:

```go
func (s *Server) Start(ctx context.Context) error {
    // Start server in goroutine
    go func() {
        errChan <- s.app.Listen(addr)
    }()
    
    // Wait for shutdown signal
    select {
    case <-ctx.Done():
        // Graceful shutdown with 30s timeout
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        
        s.app.ShutdownWithContext(shutdownCtx)
        s.db.Close()        // Close database
        s.redisClient.Close() // Close Redis
        
    case err := <-errChan:
        return err
    }
}
```

## Production Deployment

### Single Binary Deployment
```bash
# Build produces a single, self-contained binary
make build-server

# Deploy by copying binary + config
scp bin/server user@prod-server:/opt/mvp-auth/
scp configs/prod.yaml user@prod-server:/opt/mvp-auth/

# Run with production config
./server --config=/opt/mvp-auth/prod.yaml
```

### Container Deployment
```bash
# Build container
make build  # Includes Docker image build

# Deploy container
docker run -d \
  --name mvp-auth-prod \
  -p 8080:8080 \
  -e DATABASE_URL=postgres://... \
  -e REDIS_URL=redis://... \
  mvp-auth:latest
```

### Kubernetes Deployment
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mvp-auth
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mvp-auth
  template:
    metadata:
      labels:
        app: mvp-auth
    spec:
      containers:
      - name: mvp-auth
        image: mvp-auth:v1.0.0
        ports:
        - containerPort: 8080
        - containerPort: 9000  # Metrics
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: mvp-auth-secrets
              key: database-url
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
```